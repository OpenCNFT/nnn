package trace2

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"strings"
	"time"

	"gitlab.com/gitlab-org/gitaly/v15/internal/structerr"
	"gitlab.com/gitlab-org/gitaly/v15/internal/tracing"
)

// Parser parses the events generated by Git Trace2 API to a tree data structure. The events are
// structured as a flat list of events. They are sorted in chronological order. Each event describes
// a certain sub operation, including some relative data and metadata. Some events, such as
// "region_enter" or "cmd_start", indicate a new section in which the consecutive events belong to.
// Correspondingly, exiting events, such as "region_leave" or "atexit", exits the current section.
// Trace2 also captures the events of children processes.
//
// By default, all events include "time", "file", and "line" fields. Those fields increase the size
// and processing overhead significantly. In production environment, they can be omitted by setting
// GIT_TRACE2_BRIEF environment variable. Afterward, we can only extract the time from the initial
// process events. The times of other events could be inferred from the time difference relative to
// the first event ("t_abs" field) or the current section ("t_rel" field).
//
// Apart from the processing events, Trace2 API also exposes useful statistical information. They
// are stored in "data" and "data_json" event under "key" and "value" fields. They are particularly
// useful to sample and expose internal Git metrics.
//
// The result of the parsing process is a root Trace node of the tree. The root node is a dummy node,
// not a part of the original events. So, it's recommended to skip this node when walking.
//
// For more information, please visit Trace2 API: https://git-scm.com/docs/api-trace2
type Parser struct {
	root    *Trace
	pointer *Trace
}

// timeLayout defines the absolute timestamp format of trace2 event
const timeLayout = "2006-01-02T15:04:05.000000Z"

// jsonEvent is a simplified version of Trace2 event format. Each event may have different fields
// according to event type. The full format can be found here:
// https://git-scm.com/docs/api-trace2#_event_format
type jsonEvent struct {
	Name      string           `json:"event"`
	Category  string           `json:"category"`
	Label     string           `json:"label"`
	Thread    string           `json:"thread"`
	DataKey   string           `json:"key"`
	DataValue *json.RawMessage `json:"value"`
	Time      string           `json:"time"`
	TimeAbs   float64          `json:"t_abs"`
	TimeRel   float64          `json:"t_rel"`
	Argv      []string         `json:"argv"`
	ChildID   int              `json:"child_id"`
	Msg       string           `json:"msg"`
	Code      int              `json:"code"`
}

var ignoredEvents = map[string]struct{}{
	"version":  {},
	"cmd_name": {},
	"exit":     {},
}

// Parse receives a reader object and returns the root trace of the tree. The parser reads line by
// line. Each line stores an event under JSON format. It doesn't rewind the reader.
func (p *Parser) Parse(ctx context.Context, reader io.Reader) (*Trace, error) {
	span, _ := tracing.StartSpanIfHasParent(ctx, "trace2.Parse", nil)
	defer span.Finish()

	p.root = nil
	p.pointer = nil

	decoder := json.NewDecoder(reader)
	for {
		var event jsonEvent
		err := decoder.Decode(&event)
		if err != nil {
			if err == io.EOF {
				return p.root, nil
			}
			return nil, fmt.Errorf("decode event: %w", err)
		}

		err = p.parseEvent(&event)
		if err != nil {
			p.root = nil
			return nil, structerr.NewInternal("process event: %w", err).WithMetadata("event", event)
		}
	}
}

func (p *Parser) parseEvent(event *jsonEvent) error {
	if _, ok := ignoredEvents[event.Name]; ok {
		return nil
	}

	var trace *Trace
	t, err := p.parseEventTime(p.pointer, event)
	if err != nil {
		return fmt.Errorf("parse event time: %w", err)
	}

	if p.root == nil {
		trace = &Trace{Thread: event.Thread, StartTime: t, Name: "root"}
		p.root = trace
		p.pointer = p.root
	}

	if p.pointer == nil {
		// Invalid exit sequence. Just in case
		p.pointer = p.root
	}

	// Escape commands, don't create trace
	switch event.Name {
	case "atexit", "child_exit":
		p.pointer.FinishTime = t
		p.pointer.setMetadata("code", fmt.Sprintf("%d", event.Code))
		p.pointer = p.pointer.Parent
		return nil
	case "region_leave":
		p.pointer.FinishTime = t
		p.pointer = p.pointer.Parent
		return nil
	}

	trace = &Trace{
		ChildID:    p.pointer.ChildID,
		Thread:     event.Thread,
		StartTime:  t,
		FinishTime: t,
		Parent:     p.pointer,
		Depth:      p.pointer.Depth + 1,
	}
	if event.Msg != "" {
		trace.setMetadata("msg", event.Msg)
	}
	p.pointer.Children = append(p.pointer.Children, trace)

	switch event.Name {
	case "start":
		trace.setName([]string{event.Name, event.Category, event.Label})
		trace.setMetadata("argv", strings.Join(event.Argv, " "))
	case "child_start":
		trace.setName([]string{event.Name, event.Category, event.Label})
		trace.setMetadata("argv", strings.Join(event.Argv, " "))
		trace.ChildID = fmt.Sprintf("%d", event.ChildID)
		p.pointer = trace
	case "region_enter":
		trace.setName([]string{event.Category, event.Label})
		p.pointer = trace
	case "data":
		trace.setName([]string{event.Name, event.Category, event.Label, event.DataKey})
		if event.DataValue != nil {
			var data string
			// When the event name is "data", we can unmarshal the data. This allows
			// easy data access later
			err := json.Unmarshal(*event.DataValue, &data)
			if err != nil {
				return fmt.Errorf("mismatched data value: %w", err)
			}
			trace.setMetadata("data", data)
		}
	case "data_json":
		trace.setName([]string{event.Name, event.Category, event.Label, event.DataKey})
		if event.DataValue != nil {
			trace.setMetadata("data", string(*event.DataValue))
		}
	default:
		trace.setName([]string{event.Name, event.Category, event.Label})
	}
	return nil
}

func (p *Parser) parseEventTime(parent *Trace, event *jsonEvent) (time.Time, error) {
	// Absolute time. If GIT_TRACE2_BRIEF env variable is set this field is attached to the
	// first event only. Other event's time must be inferred from time diff (TimeAbs and TimeRel)
	if event.Time != "" {
		return time.Parse(timeLayout, event.Time)
	}

	// Absolute time difference from the root
	if event.TimeAbs != 0 {
		return p.addTime(p.rootTime(), event.TimeAbs), nil
	}

	var parentTime time.Time
	if parent != nil {
		parentTime = parent.StartTime
	} else {
		parentTime = p.rootTime()
	}

	// Relative time difference from its parent
	if event.TimeRel != 0 {
		return p.addTime(parentTime, event.TimeRel), nil
	}

	// If an event doesn't have either TimeAbs and TimeRel, infer the time from its prior sibling
	if parent != nil && len(parent.Children) != 0 {
		return parent.Children[len(parent.Children)-1].FinishTime, nil
	}

	// If the event is the only child without any further information, use its parent time
	return parentTime, nil
}

func (p *Parser) rootTime() time.Time {
	if p.root != nil {
		return p.root.StartTime
	}
	return time.Now()
}

func (p *Parser) addTime(t time.Time, diff float64) time.Time {
	return t.Add(time.Duration(1000000*diff) * time.Microsecond)
}
